\chapter{多任务队列调度算法}
针对协同边缘计算环境中多分布式学习作业的在线调度问题，本文提出一种融合滚动窗口、资源感知贪心排序与动态饥饿保护的混合启发式调度算法。该算法在CPU、内存、链路带宽等多维资源约束下，联合优化带宽满足度、系统负载均衡度与作业平均等待时间三个相互冲突的指标。首先，基于系统负载动态确定候选作业窗口，平衡决策复杂度与调度机会；其次，通过资源适配度、业务优先级与等待因子计算综合评分，优先调度与剩余资源最匹配的作业；最后，引入跳过计数阈值与强制预留机制防止低优先级作业饥饿。本文详细给出了问题形式化模型、算法伪代码与复杂度分析，并设计了完整的仿真实验方案，包括物理拓扑生成、作业到达过程、对比算法与多维度评估指标，为后续实现与性能验证奠定理论基础。
\section{问题建模}
随着深度学习模型在边缘智能场景中的广泛应用，越来越多的分布式学习作业需要部署在资源受限的边缘节点上。这些作业通常包含多个协同计算的任务节点及任务间的通信链路，对计算资源（CPU、内存）与网络资源（带宽）均有需求。如何在满足物理资源约束的前提下，高效、公平地调度多批作业，已成为边缘计算资源管理领域的关键挑战。

现有研究往往将作业调度分解为两个独立阶段：先决定作业的执行顺序，再为单个作业分配计算节点与带宽资源。这种分阶段方法容易造成目标冲突——例如，仅按优先级排序可能忽略资源匹配度，导致资源碎片化；仅按资源需求大小排序则可能使大作业长期阻塞小作业。此外，多数调度器未显式考虑作业间的带宽竞争，或仅以最小带宽保障为目标，难以逼近最大带宽需求。

为解决上述问题，本文提出一种\textbf{多作业队列在线调度算法}（Multi-Job Online Scheduling, MJOS），其核心创新包括：

\begin{itemize}
    \item \textbf{联合调度框架}：将计算资源与网络资源统一纳入调度决策，避免分阶段优化的次优性；
    \item \textbf{动态滚动窗口}：根据当前运行队列的负载情况自适应调整候选作业窗口大小，在决策开销与调度性能间取得平衡；
    \item \textbf{资源感知评分}：从CPU、内存、带宽三个维度计算作业需求与系统剩余资源的匹配程度，优先调度最能填补资源空缺的作业；
    \item \textbf{饥饿保护机制}：通过跳过计数与等待时间监控，对长期未获调度的作业实施优先级提升或强制资源预留，保障公平性。
\end{itemize}

本文所述算法与现有的单作业调度器（如基于强化学习的PPO分配器）完全兼容，可作为上层调度器集成至CES（Collaborative Edge System）等边缘计算平台。下文将详细介绍问题建模、算法设计及复杂度分析。

\subsection{系统模型}

考虑一个协同边缘计算系统，包含一个中心调度器及若干边缘节点。系统维护两个队列：\textbf{等待调度队列} $\mathcal{Q}_{\text{wait}}$ 存放已到达但尚未获得资源的作业；\textbf{运行队列} $\mathcal{Q}_{\text{run}}$ 存放正在执行的作业。调度器在每个离散时间步 $t$ 观察系统状态，从 $\mathcal{Q}_{\text{wait}}$ 中选择若干作业尝试分配资源，成功则移入 $\mathcal{Q}_{\text{run}}$。

\subsubsection{物理网络资源}
\begin{itemize}
    \item 物理节点集合：$\mathcal{P} = \{p_1, p_2, \dots, p_M\}$，$M = |\mathcal{P}|$。
    \item 物理链路集合：$\mathcal{R} = \{r_1, r_2, \dots, r_L\}$，$L = |\mathcal{R}|$。链路为双向，带宽对称。
    \item 节点 $p$ 的总资源：$C_p^{\text{CPU}}$（CPU核数或单位），$R_p^{\text{RAM}}$（内存大小）。运行中占用资源为已分配给运行作业任务的部分，剩余空闲资源记为 $A_p^{\text{CPU}}(t)$、$A_p^{\text{RAM}}(t)$。
    \item 链路 $r$ 的总带宽：$B_r^{\text{total}}$。已分配带宽记为 $U_r(t)$，剩余带宽 $A_r^{\text{BW}}(t) = B_r^{\text{total}} - U_r(t)$。
\end{itemize}

\subsubsection{作业模型}

每个作业 $j \in \mathcal{J}$ 具有以下属性：
\begin{itemize}
    \item 任务节点集 $\mathcal{N}_j = \{n_{j1}, \dots, n_{jK_j}\}$，$K_j = |\mathcal{N}_j|$。
    \item 通信链路集 $\mathcal{V}_j = \{v_{j1}, \dots, v_{jE_j}\}$，$E_j = |\mathcal{V}_j|$，每条链路连接两个任务节点。
    \item 任务节点 $n$ 的资源需求：$\text{CPU}^N(n)$，$\text{RAM}^N(n)$。实际映射时，每个任务需独占式分配完整需求。
    \item 通信链路 $v$ 的带宽需求区间：$[b_v^{\min}, b_v^{\max}]$，调度器应至少分配 $b_v^{\min}$，并尽可能接近 $b_v^{\max}$。
    \item 优先级权重 $w_j \in [1,5]$，整数，数值越大表示业务紧急程度越高。
    \item 到达时间 $t_j^{\text{arr}}$；开始时间 $t_j^{\text{start}}$；等待时间 $T_j^{\text{wait}} = t_j^{\text{start}} - t_j^{\text{arr}}$（若尚未开始，则为 $t - t_j^{\text{arr}}$）。
\end{itemize}

\subsubsection{映射与资源分配约束}

设二元决策变量 $X_{p}^{n}(j) \in \{0,1\}$ 表示作业 $j$ 的任务 $n$ 是否放置在物理节点 $p$；$Y_{r}^{v}(j) \in \{0,1\}$ 表示作业 $j$ 的虚拟链路 $v$ 是否占用物理链路 $r$。则约束如下：

\begin{enumerate}
    \item \textbf{节点资源约束}（任一时刻 $t$）：
    \begin{align}
        &\forall p \in \mathcal{P}: \sum_{j \in \mathcal{Q}_{\text{run}}(t)} \sum_{n \in \mathcal{N}_j} X_{p}^{n}(j) \cdot \text{CPU}^N(n) \le C_p^{\text{CPU}}, \\
        &\forall p \in \mathcal{P}: \sum_{j \in \mathcal{Q}_{\text{run}}(t)} \sum_{n \in \mathcal{N}_j} X_{p}^{n}(j) \cdot \text{RAM}^N(n) \le R_p^{\text{RAM}}.
    \end{align}
    
    \item \textbf{链路带宽约束}（任一时刻 $t$）：
    \begin{equation}
        \forall r \in \mathcal{R}: \sum_{j \in \mathcal{Q}_{\text{run}}(t)} \sum_{v \in \mathcal{V}_j} Y_{r}^{v}(j) \cdot b_v^{\text{alloc}} \le B_r^{\text{total}},
    \end{equation}
    其中 $b_v^{\text{alloc}} \in [b_v^{\min}, b_v^{\max}]$ 为实际分配给链路 $v$ 的带宽。
    
    \item \textbf{任务映射唯一性}：
    \begin{equation}
        \forall j, \forall n \in \mathcal{N}_j: \sum_{p \in \mathcal{P}} X_{p}^{n}(j) = 1.
    \end{equation}
    
    \item \textbf{链路路径约束}：若任务 $n_i$ 映射至 $p_a$，任务 $n_k$ 映射至 $p_b$，且虚拟链路 $v = (n_i, n_k)$，则 $Y_{r}^{v}(j)=1$ 当且仅当物理链路 $r$ 位于从 $p_a$ 到 $p_b$ 的最短路径上。本文假设采用静态最短路径路由。
    
    \item \textbf{作业非抢占}：作业一旦开始执行，在完成前不中断，不释放资源。
\end{enumerate}

\subsection{性能指标}

为量化调度质量，定义三个核心指标，分别对应带宽、负载均衡与延迟。

\subsubsection{带宽需求满足度}

对于运行中的作业 $j$，定义其带宽满足度为所有虚拟链路实际分配带宽与最大需求比值的平均值：
\begin{equation}
    D_{\text{BW}}(j) = \frac{1}{|\mathcal{V}_j|} \sum_{v \in \mathcal{V}_j} \frac{b_v^{\text{alloc}}}{b_v^{\max}}.
\end{equation}
若作业所有任务映射至同一节点（无通信），则定义 $D_{\text{BW}}(j) = 1$。系统整体带宽满足度为运行队列中作业的平均值：
\begin{equation}
    \bar{D}_{\text{BW}}(t) = \frac{1}{|\mathcal{Q}_{\text{run}}(t)|} \sum_{j \in \mathcal{Q}_{\text{run}}(t)} D_{\text{BW}}(j).
\end{equation}

\subsubsection{系统负载均衡度}

负载均衡度衡量三类资源在物理节点/链路上的利用分布均匀性。首先计算节点 $p$ 的CPU利用率 $\rho_p^{\text{CPU}}(t) = 1 - A_p^{\text{CPU}}(t)/C_p^{\text{CPU}}$，内存利用率 $\rho_p^{\text{RAM}}(t)$ 类似。链路 $r$ 的带宽利用率 $\rho_r^{\text{BW}}(t) = U_r(t)/B_r^{\text{total}}$。

定义资源 $x$（CPU、RAM、BW）的\textbf{不均衡系数}为各实体利用率的变异系数（标准差/均值）：
\begin{equation}
    L_t^{x} = \frac{\sqrt{\frac{1}{M_x} \sum_{i=1}^{M_x} (\rho_i^x - \bar{\rho}^x)^2}}{\bar{\rho}^x + \epsilon},
\end{equation}
其中 $M_x$ 为对应实体数量（节点数或链路数），$\epsilon$ 避免除零。整体负载均衡度加权组合：
\begin{equation}
    L_t = w_1 L_t^{\text{CPU}} + w_2 L_t^{\text{RAM}} + w_3 L_t^{\text{BW}}, \quad w_1+w_2+w_3=1.
\end{equation}
本文取默认权重 $(0.4,0.4,0.2)$。$L_t$ 越小表示资源利用越均衡。

\subsubsection{作业平均等待时间}

在时刻 $t$，所有\textbf{已到达}作业的平均等待时间：
\begin{equation}
    \bar{T}_{\text{wait}}(t) = \frac{1}{|\mathcal{Q}_{\text{wait}}(t) \cup \mathcal{Q}_{\text{run}}(t)|} \sum_{j \in \mathcal{Q}_{\text{wait}} \cup \mathcal{Q}_{\text{run}}} (t - t_j^{\text{arr}}).
\end{equation}
对于已完成作业，其等待时间固定为 $t_j^{\text{start}}-t_j^{\text{arr}}$。

\subsection{优化目标}

本文采用\textbf{加权和法}将多目标问题转化为单目标优化。在每个调度时刻 $t$，选择待调度作业子集 $S_t \subseteq \mathcal{Q}_{\text{wait}}(t)$，使得调度后的系统综合性能最大：
\begin{equation}
    \max_{S_t} \; \alpha_1 \bar{D}_{\text{BW}}(t+|S_t|) + \alpha_2 \left(1 - L_{t+|S_t|}\right) + \alpha_3 \left(1 - \frac{\bar{T}_{\text{wait}}(t+|S_t|)}{T_{\max}}\right),
\end{equation}
其中 $\alpha_1=0.5$，$\alpha_2=0.3$，$\alpha_3=0.2$，$T_{\max}$ 为最大容忍等待时间（设为仿真长度或经验值）。约束条件同第\ref{sec:model}节。

由于未来状态依赖于当前调度决策且作业到达随机，精确在线优化极为困难。因此，本文设计一种启发式算法，在每个时刻仅调度\textbf{至多一个}作业（或少量作业），以贪心方式逼近上述目标。

\section{算法设计}
\subsection{总体框架}
本文提出的\textbf{多作业在线调度算法}（Multi-Job Online Scheduling, MJOS）由四个核心模块构成：

\begin{enumerate}
    \item \textbf{滚动窗口选择}：根据当前系统负载，从 $\mathcal{Q}_{\text{wait}}$ 中选出有限个作业作为候选集 $C$，避免每步遍历整个队列。
    \item \textbf{综合评分计算}：对每个候选作业，计算资源适配度、优先级得分与等待因子，加权得到总评分。
    \item \textbf{贪心调度尝试}：按评分降序依次调用单作业调度器尝试分配资源，成功则更新系统状态并移动作业。
    \item \textbf{饥饿保护}：监控长期未获调度的作业，通过提升优先级或强制预留方式提高其调度机会。
\end{enumerate}

算法\ref{alg:MJOS}给出了MJOS的顶层伪代码。

\begin{algorithm}[htbp]
    \caption{多作业在线调度算法（MJOS）}
    \label{alg:MJOS}
    \begin{algorithmic}[1]
        \Require 等待队列 $\mathcal{Q}_{\text{wait}}$，运行队列 $\mathcal{Q}_{\text{run}}$，物理网络状态 $(\mathcal{P},\mathcal{R})$，参数 $\beta,\tau,\theta,K,T_{\text{th}}$
        \Ensure 更新后的 $\mathcal{Q}_{\text{wait}}$，$\mathcal{Q}_{\text{run}}$ 及资源状态
        
        \For{每个调度周期}
            \State // 步骤1：滚动窗口选择
            \State $W \gets \min\left( \left\lfloor \beta \cdot \dfrac{\sum_{p} A_p^{\text{CPU}}}{ \max_p C_p^{\text{CPU}} } \cdot |\mathcal{P}| \right\rfloor,\; |\mathcal{Q}_{\text{wait}}| \right)$
            \State $C \gets \{j_1, j_2, \dots, j_W\}$，即 $\mathcal{Q}_{\text{wait}}$ 的前 $W$ 个作业（按到达时间排序）
            
            \State // 步骤2：为每个候选作业计算综合评分
            \For{each $j \in C$}
                \State $R_{\text{match}}(j) \gets \text{ComputeResourceMatch}(j)$  \Comment{式(13)}
                \State $S_{\text{wait}}(j) \gets 1 - \exp\left(-\dfrac{t - t_j^{\text{arr}}}{\tau}\right)$
                \State $S_{\text{total}}(j) \gets 0.6 \cdot R_{\text{match}}(j) + 0.3 \cdot \dfrac{w_j}{5} + 0.1 \cdot S_{\text{wait}}(j)$
            \EndFor
            
            \State // 步骤3：按评分降序尝试调度
            \State 将 $C$ 按 $S_{\text{total}}$ 降序排列
            \For{each $j$ in sorted $C$}
                \State $success \gets \text{TryMapJob}(j)$  \Comment{调用单作业调度器}
                \If{$success$}
                    \State 将 $j$ 从 $\mathcal{Q}_{\text{wait}}$ 移至 $\mathcal{Q}_{\text{run}}$，更新资源状态
                    \State 重置 $j$ 的跳过计数 $\text{skip}(j) \gets 0$
                    \State \textbf{break}  \Comment{本周期只调度一个作业（可根据配置调度多个）}
                \Else
                    \State $\text{skip}(j) \gets \text{skip}(j) + 1$
                \EndIf
            \EndFor
            
            \State // 步骤4：饥饿保护处理
            \For{each $j \in \mathcal{Q}_{\text{wait}}$}
                \If{$t - t_j^{\text{arr}} > T_{\text{th}}$}
                    \State 临时提升 $w_j \gets \min(w_j+1, 5)$  \Comment{优先级提升}
                \EndIf
                \If{$\text{skip}(j) \ge K$}
                    \State $\text{TryForceMap}(j)$  \Comment{尝试预留最小资源包}
                \EndIf
            \EndFor
        \EndFor
    \end{algorithmic}
\end{algorithm}

\subsection{滚动窗口机制}
窗口大小 $W_t$ 动态计算，其基本思想是：当系统剩余资源较多时，应扩大候选窗口，增加调度机会；当系统资源紧张时，缩小窗口，避免频繁失败尝试。具体公式：
\begin{equation}
    W_t = \min\left( \left\lfloor \beta \cdot \frac{\sum_{p \in \mathcal{P}} A_p^{\text{CPU}}(t)}{\max_{p \in \mathcal{P}} C_p^{\text{CPU}}} \cdot |\mathcal{P}| \right\rfloor,\; |\mathcal{Q}_{\text{wait}}(t)| \right),
\end{equation}
其中 $\beta \in [1,3]$ 为窗口扩展因子，默认 $\beta=2$。分母使用最大节点CPU容量以归一化。若全部节点CPU空闲率均为100\%，则 $W_t = \beta |\mathcal{P}|$；若系统满载，则 $W_t=0$，不调度新作业。窗口内作业按\textbf{先入先出}顺序选取，即最早到达的 $W_t$ 个作业。

该机制与实现代码中 $W = \min(\text{max\_load\_factor} \cdot |P|, |\text{queue}|)$ 形式兼容，但此处将固定因子 $\text{max\_load\_factor}$ 替换为负载自适应因子，更符合理论模型的动态特性。

\subsection{资源适配度计算}
资源适配度 $R_{\text{match}}(j)$ 衡量作业 $j$ 的总资源需求与当前网络剩余资源的匹配程度。为简化计算，采用\textbf{最大空闲资源归一化}方法：分别找出CPU、内存、带宽在各自实体中的最大空闲量，然后计算需求与该最大值的比值，并截断至1。数学表达式为：
\begin{equation}
    R_{\text{match}}(j) = \frac{1}{3} \left[ \min\left(1, \frac{\text{CPU}^{\text{dem}}(j)}{\max_{p \in \mathcal{P}} A_p^{\text{CPU}}}\right) + \min\left(1, \frac{\text{RAM}^{\text{dem}}(j)}{\max_{p \in \mathcal{P}} A_p^{\text{RAM}}}\right) + \min\left(1, \frac{\text{BW}^{\text{dem}}(j)}{\max_{r \in \mathcal{R}} A_r^{\text{BW}}}\right) \right],
    \label{eq:match}
\end{equation}
其中：
\begin{itemize}
    \item $\text{CPU}^{\text{dem}}(j) = \sum_{n \in \mathcal{N}_j} \text{CPU}^N(n)$，作业总CPU需求；
    \item $\text{RAM}^{\text{dem}}(j) = \sum_{n \in \mathcal{N}_j} \text{RAM}^N(n)$，作业总内存需求；
    \item $\text{BW}^{\text{dem}}(j) = \sum_{v \in \mathcal{V}_j} b_v^{\min}$（或使用 $b_v^{\max}$，本文采用 $b_v^{\min}$ 作为保守估计）。
\end{itemize}

该归一化方式计算简单，且能反映作业需求是否超过当前网络中任何单节点/链路的剩余能力。若所有空闲资源均大于需求，则 $R_{\text{match}}=1$；若需求超过最大空闲资源，则比值小于1，鼓励调度需求较小的作业。

\subsection{综合评分}
每个候选作业的综合评分 $S_{\text{total}}(j)$ 由三部分加权组成：

\begin{itemize}
    \item \textbf{资源适配度} $R_{\text{match}}(j)$，权重0.6 —— 反映即时资源匹配程度，是调度决策的主要依据。
    \item \textbf{优先级得分} $\dfrac{w_j}{5}$，权重0.3 —— 归一化至 $[0.2,1]$，体现业务紧急程度。
    \item \textbf{等待时间因子} $S_{\text{wait}}(j)$，权重0.1 —— 采用指数函数 $S_{\text{wait}}(j)=1-\exp\left(-\dfrac{t-t_j^{\text{arr}}}{\tau}\right)$，其中 $\tau$ 为等待敏感参数（默认 $\tau=50$）。等待时间越长，该因子越接近1，防止作业饥饿。
\end{itemize}

因此：
\begin{equation}
    S_{\text{total}}(j) = 0.6 \cdot R_{\text{match}}(j) + 0.3 \cdot \frac{w_j}{5} + 0.1 \cdot S_{\text{wait}}(j).
    \label{eq:score}
\end{equation}

\subsection{饥饿保护策略}

为保障长期公平性，MJOS引入双重饥饿防护：

\begin{enumerate}
    \item \textbf{等待时间阈值提升}：若作业等待时间超过 $T_{\text{th}}$（例如100个时间单位），则将其优先级临时提升1级（不超过最大值5），使其在后续评分中获得更高优先级权重。
    \item \textbf{强制预留调度}：若作业连续被跳过 $K$ 次（例如 $K=3$），则触发强制调度尝试：系统为该作业预留一份“最小资源包”——例如，为每个任务预留最小需求（CPU/RAM），并为通信链路预留 $b_v^{\min}$ 带宽。若预留成功，则立即调度该作业；否则保留其跳过计数，待后续资源充足时再尝试。
\end{enumerate}

这两种保护机制协同工作：前者提高评分排名，后者通过资源预留保证极端情况下的调度机会。

\subsection{算法复杂度分析}

每调度周期的主要开销在于：
\begin{itemize}
    \item 计算 $W$ 个作业的综合评分：$O(W)$。
    \item 排序 $W$ 个作业：$O(W \log W)$。
    \item 每个作业尝试映射：单作业调度器复杂度记为 $O(f(K_j, M, L))$。典型贪心映射为 $O(K_j M + \text{SPF cost})$，其中SPF为最短路径计算，可采用Floyd-Warshall预处理后 $O(1)$ 查询，因此总开销 $O(K_j M)$。
    \item 饥饿保护遍历 $\mathcal{Q}_{\text{wait}}$：$O(|\mathcal{Q}_{\text{wait}}|)$。
\end{itemize}

实际中 $W$ 与 $|\mathcal{Q}_{\text{wait}}|$ 均受限于系统规模与作业到达率，算法可在毫秒级完成，适用于在线调度。

\section{实验设计}
\label{sec:experiment}

为验证MJOS算法的有效性与鲁棒性，本节设计一套完整的仿真实验框架，涵盖物理网络生成、作业负载生成、对比算法、评估指标及统计分析方法。

\subsection{仿真环境设置}

\subsubsection{物理网络拓扑}
\begin{itemize}
    \item 节点数 $M \in \{10,15,20\}$。
    \item 链路生成：随机连通图，任意节点对连接概率 $p_{\text{edge}}=0.3$，并保证图连通；若连通分量多于1，则随机添加边直至全连通。
    \item 节点资源：CPU与内存容量在区间 $[50,100]$ 内均匀随机采样，单位为“单位”。
    \item 链路带宽：在 $[100,1000]$ Mbps内均匀随机采样。
\end{itemize}

\subsubsection{作业到达过程}
\begin{itemize}
    \item 作业到达间隔服从泊松分布，到达率 $\lambda \in \{2,3,5\}$（单位：作业/时间单位）。
    \item 每个作业的任务节点数 $K_j \sim \text{Uniform}\{3,4,5,6,7,8\}$。
    \item 通信拓扑：在 $K_j$ 个任务节点间以概率 $p_{\text{comm}}=0.4$ 添加虚拟链路，并保证子图连通。
    \item 任务CPU需求：$\text{CPU}^N(n) \sim \text{Uniform}[10,50]$。
    \item 任务内存需求：$\text{RAM}^N(n) \sim \text{Uniform}[10,50]$。
    \item 带宽需求区间：每条虚拟链路的 $b_v^{\min} \sim \text{Uniform}[10,50]$，$b_v^{\max} = b_v^{\min} + \text{Uniform}[0,50]$，保证 $b_v^{\max} \ge b_v^{\min}$。
    \item 优先级权重 $w_j \sim \text{Uniform}\{1,2,3,4,5\}$。
    \item 仿真总时长：$T_{\text{sim}} = 1000$ 时间单位。
    \item 作业总数：动态生成，约为 $\lambda \cdot T_{\text{sim}}$，约200~500个。
\end{itemize}

\subsubsection{系统初始负载}
为考察不同资源紧张程度下的算法性能，设置三种初始占用水平：
\begin{itemize}
    \item \textbf{宽松}：随机将节点资源的30\%预分配给若干模拟作业（运行队列中）；
    \item \textbf{中等}：50\%初始占用；
    \item \textbf{紧张}：70\%初始占用。
\end{itemize}

\subsection{对比算法}

选取五种代表性调度策略作为基准。


所有算法均使用相同的单作业映射器（默认贪心首次适应）以保证公平对比。后续可扩展实验对比不同单作业调度器的影响。



所有指标均在仿真结束时统计，部分时间序列指标（如平均等待时间、带宽满足度）按每100个时间单位采样记录演化趋势。

\subsection{实验方案与统计方法}




\section{本章小结}
本文面向协同边缘计算环境下的多分布式学习作业调度问题，提出了一种在线启发式调度算法MJOS。该算法通过动态滚动窗口控制决策规模，利用资源感知评分引导作业调度顺序，并引入等待时间阈值与强制预留机制防止饥饿，综合优化了带宽满足度、负载均衡度与平均等待时间三个相互冲突的指标。与现有分阶段调度方法相比，MJOS将计算与网络资源联合考虑，且与任意单作业调度器兼容，具有良好的可扩展性与实用性。

文章完成了问题形式化建模、算法详细设计及完整的仿真实验方案。后续工作将基于所述实验设计进行代码实现与大规模仿真验证，并探索以下方向：（1）将窗口自适应因子 $\beta$ 与等待敏感参数 $\tau$ 动态在线调优；（2）引入多作业并行调度能力，进一步提升资源利用率；（3）将MJOS扩展至异构资源（如GPU、NPU）场景。
